name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-release:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            bundles: nsis,msi
            extra_args: ""
          - os: macos-14
            bundles: dmg,app
            extra_args: --target x86_64-apple-darwin
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22.19.0
          cache: npm
          cache-dependency-path: app/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Add x86_64 target (macOS)
        if: matrix.os == 'macos-14'
        run: rustup target add x86_64-apple-darwin

      - name: Install Node deps (app)
        working-directory: app
        shell: bash
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      # Cache FFmpeg archive for Windows
      - name: Cache FFmpeg downloads (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/cache@v4
        with:
          path: app/src-tauri/.cache/ffmpeg/windows
          key: ffmpeg-win64-latest-${{ github.run_id }}
          restore-keys: |
            ffmpeg-win64-latest-

      # Download, verify, and extract only the required files for Windows
      - name: Prepare FFmpeg (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $Base = "app/src-tauri"
          $Cache = "$Base/.cache/ffmpeg/windows"
          $BinOut = "$Base/binaries"
          New-Item -ItemType Directory -Force -Path $Cache, $BinOut | Out-Null

          # Using latest stable release (not autobuild) to avoid 404 errors
          $Url = "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl-shared.zip"
          $Zip = Join-Path $Cache "ffmpeg-master-latest-win64-gpl-shared.zip"
          
          # Always download fresh to get latest version
          if (Test-Path $Zip) { Remove-Item $Zip -Force }
          Invoke-WebRequest -Uri $Url -OutFile $Zip -UseBasicParsing

          # Extract zip
          $Tmp = Join-Path $Cache "win-extract"
          if (Test-Path $Tmp) { Remove-Item -Recurse -Force $Tmp }
          Expand-Archive -Path $Zip -DestinationPath $Tmp -Force

          # Find the inner bin folder dynamically
          $InnerBin = Get-ChildItem -Path $Tmp -Directory | Select-Object -First 1
          $InnerBin = Join-Path $InnerBin.FullName "bin"
          if (-not (Test-Path $InnerBin)) {
            throw "Inner bin folder not found: $InnerBin"
          }

          # Clean output to ensure no unnecessary files
          Get-ChildItem -Path $BinOut -Force -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse

          # Copy ffmpeg.exe, ffprobe.exe and all required DLLs dynamically
          Copy-Item -Force (Join-Path $InnerBin "ffmpeg.exe") $BinOut
          Copy-Item -Force (Join-Path $InnerBin "ffprobe.exe") $BinOut
          
          # Copy all av*, sw* DLLs (handles version number changes)
          Get-ChildItem -Path $InnerBin -Filter "av*.dll" | Copy-Item -Destination $BinOut -Force
          Get-ChildItem -Path $InnerBin -Filter "sw*.dll" | Copy-Item -Destination $BinOut -Force
          
          Get-ChildItem $BinOut | ForEach-Object { Write-Host "Prepared $($_.Name)" }

      # Cache FFmpeg archives for macOS
      - name: Cache FFmpeg downloads (macOS)
        if: matrix.os == 'macos-14'
        uses: actions/cache@v4
        with:
          path: app/src-tauri/.cache/ffmpeg/macos
          key: ffmpeg-macos-evermeet-8.0
          restore-keys: |
            ffmpeg-macos-

      # Download, extract, chmod +x, and de-quarantine FFmpeg for macOS
      - name: Prepare FFmpeg sidecars (macOS)
        if: matrix.os == 'macos-14'
        shell: bash
        run: |
          set -euo pipefail
          
          BASE="app/src-tauri"
          CACHE="$BASE/.cache/ffmpeg/macos"
          BIN="$BASE/binaries"
          mkdir -p "$CACHE" "$BIN"
          
          FFMPEG_URL="https://evermeet.cx/ffmpeg/ffmpeg-8.0.zip"
          FFPROBE_URL="https://evermeet.cx/ffmpeg/ffprobe-8.0.zip"
          
          [ -f "$CACHE/ffmpeg-8.0.zip" ]  || curl -L --retry 3 -o "$CACHE/ffmpeg-8.0.zip"  "$FFMPEG_URL"
          [ -f "$CACHE/ffprobe-8.0.zip" ] || curl -L --retry 3 -o "$CACHE/ffprobe-8.0.zip" "$FFPROBE_URL"
          
          rm -f "$BIN/"* || true
          
          unzip -o "$CACHE/ffmpeg-8.0.zip"  -d "$BIN"
          unzip -o "$CACHE/ffprobe-8.0.zip" -d "$BIN"
          
          chmod +x "$BIN/ffmpeg" "$BIN/ffprobe" || true
          xattr -dr com.apple.quarantine "$BIN/ffmpeg" "$BIN/ffprobe" 2>/dev/null || true
          
          # Create target-suffixed copies expected by Tauri when using --target x86_64-apple-darwin
          cp "$BIN/ffmpeg"  "$BIN/ffmpeg-x86_64-apple-darwin"
          cp "$BIN/ffprobe" "$BIN/ffprobe-x86_64-apple-darwin"
          chmod +x "$BIN/ffmpeg-x86_64-apple-darwin" "$BIN/ffprobe-x86_64-apple-darwin" || true
          xattr -dr com.apple.quarantine "$BIN/ffmpeg-x86_64-apple-darwin" "$BIN/ffprobe-x86_64-apple-darwin" 2>/dev/null || true
          
          ls -la "$BIN"


      - name: Build with Tauri (no release)
        if: github.event_name == 'workflow_dispatch'
        uses: tauri-apps/tauri-action@v0
        with:
          projectPath: app
          args: --bundles ${{ matrix.bundles }} ${{ matrix.extra_args }}

      - name: Build and release with Tauri
        if: startsWith(github.ref, 'refs/tags/v')
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: app
          tagName: ${{ github.ref_name }}
          releaseName: Free FPS ${{ github.ref_name }}
          releaseBody: |
            Downloads:
            - Windows portable: `free-fps_portable.zip`
            - Windows installer (NSIS): `Free.FPS_*_x64-setup.exe`
            - Windows installer (MSI): `Free.FPS_*_x64_en-US.msi`
            - macOS Intel: `Free.FPS_*_x64.dmg`
          releaseDraft: false
          prerelease: false
          args: --bundles ${{ matrix.bundles }} ${{ matrix.extra_args }}

      - name: Create portable.zip (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $Base    = "app/src-tauri"
          $Release = Join-Path $Base "target\release"
          $Stage   = Join-Path $Release "portable"
          $OutZip  = Join-Path $Release "free-fps_portable.zip"
          
          if (Test-Path $Stage) { Remove-Item -Recurse -Force $Stage }
          New-Item -ItemType Directory -Force -Path $Stage | Out-Null
          
          # Find the portable exe and copy as free-fps.exe
          $Exe = Get-ChildItem -Path $Release -Filter *.exe -File |
            Where-Object { $_.Name -notmatch 'setup|msi' } |
            Select-Object -First 1
          if (-not $Exe) { throw "Portable exe not found in $Release" }
          Copy-Item $Exe.FullName (Join-Path $Stage "free-fps.exe") -Force
          
          # Include FFmpeg sidecars
          Copy-Item -Recurse -Force (Join-Path $Base "binaries") (Join-Path $Stage "binaries")
          
          # Collect licenses into licenses/, excluding release/stage paths
          $LicDir = Join-Path $Stage "licenses"
          New-Item -ItemType Directory -Force -Path $LicDir | Out-Null
          
          $ReleaseFull = (Resolve-Path $Release).Path
          $StageFull   = (Resolve-Path $Stage).Path
          $LicenseFiles = Get-ChildItem -Path ".", "app", "app/src-tauri" `
            -Include LICENSE*,COPYING*,NOTICE*,THIRD* -File -Recurse -ErrorAction SilentlyContinue |
            Where-Object {
              $p = $_.FullName
              -not ($p.StartsWith($StageFull, [System.StringComparison]::OrdinalIgnoreCase)) -and
              -not ($p.StartsWith($ReleaseFull, [System.StringComparison]::OrdinalIgnoreCase))
            } | Select-Object -Unique
          
          if ($LicenseFiles) {
            $LicenseFiles | Copy-Item -Destination $LicDir -Force
          }
          
          if (Test-Path $OutZip) { Remove-Item $OutZip -Force }
          Compress-Archive -Path (Join-Path $Stage "*") -DestinationPath $OutZip -Force
          Write-Host "Created $OutZip"

      - name: Attach portable.zip (Windows)
        if: matrix.os == 'windows-latest' && startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: app/src-tauri/target/release/free-fps_portable.zip
          tag_name: ${{ github.ref_name }}
          fail_on_unmatched_files: true

      - name: Upload MSI as workflow artifact (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: msi-windows
          path: app/src-tauri/target/release/bundle/msi/*.msi
          if-no-files-found: error
          retention-days: 1

  # NOTE: Azure upload disabled - not currently in use
  # upload-msi-to-azure:
  #   name: Upload MSI to Azure
  #   needs: build-and-release
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Download MSI artifact
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: msi-windows
  #         path: ./msi

  #     - name: Upload MSI to Azure Blob Storage (overwrite)
  #       uses: azure/cli@v2
  #       env:
  #         AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
  #         AZURE_STORAGE_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
  #         AZURE_CONTAINER_NAME: ${{ secrets.AZURE_CONTAINER_NAME }}
  #       with:
  #         inlineScript: |
  #           MSI_FILE=$(ls ./msi/*.msi | head -n 1)
  #           NAME=$(basename "$MSI_FILE")
  #           echo "Uploading $MSI_FILE to container '$AZURE_CONTAINER_NAME' as '$NAME'"
  #           az storage blob upload \
  #             --overwrite true \
  #             --account-name "$AZURE_STORAGE_ACCOUNT" \
  #             --account-key "$AZURE_STORAGE_KEY" \
  #             --container-name "$AZURE_CONTAINER_NAME" \
  #             --file "$MSI_FILE" \
  #             --name "$NAME"
