name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-release:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            bundles: nsis,msi
            extra_args: ""
          - os: macos-13
            bundles: dmg,app
            extra_args: --target x86_64-apple-darwin
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22.19.0
          cache: npm
          cache-dependency-path: app/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install Node deps (app)
        working-directory: app
        shell: bash
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      # Cache FFmpeg archive for Windows
      - name: Cache FFmpeg downloads (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/cache@v4
        with:
          path: app/src-tauri/.cache/ffmpeg/windows
          key: ffmpeg-win64-9bcab687db3f6457469740b559b5f9d804cd84036d6882aaa2007715205e6e90
          restore-keys: |
            ffmpeg-win64-

      # Download, verify, and extract only the required files for Windows
      - name: Prepare FFmpeg (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $Base = "app/src-tauri"
          $Cache = "$Base/.cache/ffmpeg/windows"
          $BinOut = "$Base/binaries"
          New-Item -ItemType Directory -Force -Path $Cache, $BinOut | Out-Null

          $Url = "https://github.com/BtbN/FFmpeg-Builds/releases/download/autobuild-2025-11-04-13-14/ffmpeg-N-121640-g08eda05967-win64-gpl-shared.zip"
          $Zip = Join-Path $Cache "ffmpeg-N-121640-g08eda05967-win64-gpl-shared.zip"
          if (-not (Test-Path $Zip)) {
            Invoke-WebRequest -Uri $Url -OutFile $Zip -UseBasicParsing
          }

          # Verify sha256
          $Expected = "90197b4845b87d74401ddb34ae9f6cce5e1fa59ca544c789f36ff1d3efa0d132"
          $Hash = (Get-FileHash -Algorithm SHA256 $Zip).Hash.ToLower()
          if ($Hash -ne $Expected) {
            throw "Checksum mismatch for FFmpeg zip. Expected $Expected, got $Hash"
          }

          # Extract zip
          $Tmp = Join-Path $Cache "win-extract"
          if (Test-Path $Tmp) { Remove-Item -Recurse -Force $Tmp }
          Expand-Archive -Path $Zip -DestinationPath $Tmp -Force

          # Copy only required files from /bin
          $InnerBin = Join-Path $Tmp "ffmpeg-N-121640-g08eda05967-win64-gpl-shared\bin"
          if (-not (Test-Path $InnerBin)) {
            throw "Inner bin folder not found: $InnerBin"
          }

          # Clean output to ensure no unnecessary files
          Get-ChildItem -Path $BinOut -Force -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse

          $Files = @(
            "avcodec-62.dll",
            "avdevice-62.dll",
            "avfilter-11.dll",
            "avformat-62.dll",
            "avutil-60.dll",
            "ffmpeg.exe",
            "ffplay.exe",
            "ffprobe.exe",
            "swresample-6.dll",
            "swscale-9.dll"
          )
          foreach ($f in $Files) {
            Copy-Item -Force (Join-Path $InnerBin $f) $BinOut
          }
          Get-ChildItem $BinOut | ForEach-Object { Write-Host "Prepared $($_.Name)" }

      # Cache FFmpeg archives for macOS
      - name: Cache FFmpeg downloads (macOS)
        if: matrix.os == 'macos-13'
        uses: actions/cache@v4
        with:
          path: app/src-tauri/.cache/ffmpeg/macos
          key: ffmpeg-macos-evermeet-8.0
          restore-keys: |
            ffmpeg-macos-

      # Download, extract, chmod +x, and de-quarantine FFmpeg for macOS
      - name: Prepare FFmpeg sidecars (macOS)
        if: matrix.os == 'macos-13'
        shell: bash
        run: |
          set -euo pipefail

          BASE="app/src-tauri"
          CACHE="$BASE/.cache/ffmpeg/macos"
          BIN="$BASE/binaries"
          mkdir -p "$CACHE" "$BIN"
          
          FFMPEG_URL="https://evermeet.cx/ffmpeg/ffmpeg-8.0.zip"
          FFPROBE_URL="https://evermeet.cx/ffmpeg/ffprobe-8.0.zip"
          FFPLAY_URL="https://evermeet.cx/ffmpeg/ffplay-8.0.zip"
          
          [ -f "$CACHE/ffmpeg-8.0.zip" ]  || curl -L --retry 3 -o "$CACHE/ffmpeg-8.0.zip"  "$FFMPEG_URL"
          [ -f "$CACHE/ffprobe-8.0.zip" ] || curl -L --retry 3 -o "$CACHE/ffprobe-8.0.zip" "$FFPROBE_URL"
          [ -f "$CACHE/ffplay-8.0.zip" ]  || curl -L --retry 3 -o "$CACHE/ffplay-8.0.zip"  "$FFPLAY_URL"
          
          rm -f "$BIN/"* || true
          
          unzip -o "$CACHE/ffmpeg-8.0.zip"  -d "$BIN"
          unzip -o "$CACHE/ffprobe-8.0.zip" -d "$BIN"
          unzip -o "$CACHE/ffplay-8.0.zip"  -d "$BIN"
          
          chmod +x "$BIN/ffmpeg" "$BIN/ffprobe" "$BIN/ffplay" || true
          xattr -dr com.apple.quarantine "$BIN/ffmpeg" "$BIN/ffprobe" "$BIN/ffplay" 2>/dev/null || true
          
          # Create target-suffixed copies expected by Tauri when using --target x86_64-apple-darwin
          cp "$BIN/ffmpeg"  "$BIN/ffmpeg-x86_64-apple-darwin"
          cp "$BIN/ffprobe" "$BIN/ffprobe-x86_64-apple-darwin"
          cp "$BIN/ffplay"  "$BIN/ffplay-x86_64-apple-darwin"
          chmod +x "$BIN/ffmpeg-x86_64-apple-darwin" "$BIN/ffprobe-x86_64-apple-darwin" "$BIN/ffplay-x86_64-apple-darwin" || true
          xattr -dr com.apple.quarantine "$BIN/ffmpeg-x86_64-apple-darwin" "$BIN/ffprobe-x86_64-apple-darwin" "$BIN/ffplay-x86_64-apple-darwin" 2>/dev/null || true
          
          ls -la "$BIN"

      - name: Build with Tauri (no release)
        if: github.event_name == 'workflow_dispatch'
        uses: tauri-apps/tauri-action@v0
        with:
          projectPath: app
          args: --bundles ${{ matrix.bundles }} ${{ matrix.extra_args }}

      - name: Build and release with Tauri
        if: startsWith(github.ref, 'refs/tags/v')
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: app
          tagName: v__VERSION__
          releaseName: Free FPS v__VERSION__
          releaseBody: |
            Downloads:
            - Windows portable: `free-fps.exe`
            - Windows installer (NSIS): `Free.FPS_x64-setup_windows.exe`
            - Windows installer (MSI): `Free.FPS_x64_en-US_windows.msi`
            - macOS Intel: `Free.FPS_x64_darwin.dmg`
          releaseDraft: false
          prerelease: false
          args: --bundles ${{ matrix.bundles }} ${{ matrix.extra_args }}

      - name: Create portable.zip (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $Base = "app/src-tauri"
          $Release = "$Base/target/release"
          $Stage = "$Release/portable"
          $OutZip = "$Release/free-fps_portable.zip"

          New-Item -ItemType Directory -Force -Path $Stage | Out-Null

          # Find the portable exe and copy as free-fps.exe
          $Exe = Get-ChildItem "$Release/*.exe" | Where-Object { $_.Name -notmatch 'setup|msi' } | Select-Object -First 1
          if (-not $Exe) { throw "Portable exe not found in $Release" }
          Copy-Item $Exe.FullName "$Stage/free-fps.exe" -Force

          # Include FFmpeg sidecars
          Copy-Item -Recurse -Force "$Base/binaries" "$Stage/binaries"

          # Collect licenses into licenses/
          $LicDir = "$Stage/licenses"
          New-Item -ItemType Directory -Force -Path $LicDir | Out-Null
          Get-ChildItem -Path ".", "app", "app/src-tauri" -Include LICENSE*,COPYING*,NOTICE*,THIRD* -File -Recurse -ErrorAction SilentlyContinue | `
            Copy-Item -Destination $LicDir -Force

          if (Test-Path $OutZip) { Remove-Item $OutZip -Force }
          Compress-Archive -Path "$Stage/*" -DestinationPath $OutZip -Force
          Write-Host "Created $OutZip"

      - name: Attach portable.zip (Windows)
        if: matrix.os == 'windows-latest' && startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: app/src-tauri/target/release/free-fps_portable.zip
          tag_name: ${{ github.ref_name }}
          fail_on_unmatched_files: true

      - name: Upload MSI as workflow artifact (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: msi-windows
          path: app/src-tauri/target/release/bundle/msi/*.msi
          if-no-files-found: error
          retention-days: 1

  upload-msi-to-azure:
    name: Upload MSI to Azure
    needs: build-and-release
    runs-on: ubuntu-latest
    steps:
      - name: Download MSI artifact
        uses: actions/download-artifact@v4
        with:
          name: msi-windows
          path: ./msi

      - name: Upload MSI to Azure Blob Storage (overwrite)
        uses: azure/cli@v2
        env:
          AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
          AZURE_STORAGE_KEY: ${{ secrets.AZURE_STORAGE_KEY }}
          AZURE_CONTAINER_NAME: ${{ secrets.AZURE_CONTAINER_NAME }}
        with:
          inlineScript: |
            MSI_FILE=$(ls ./msi/*.msi | head -n 1)
            echo "Uploading $MSI_FILE to container '$AZURE_CONTAINER_NAME' as 'Free.FPS_x64_en-US_windows.msi'"
            az storage blob upload \
              --overwrite true \
              --account-name "$AZURE_STORAGE_ACCOUNT" \
              --account-key "$AZURE_STORAGE_KEY" \
              --container-name "$AZURE_CONTAINER_NAME" \
              --file "$MSI_FILE" \
              --name "Free.FPS_x64_en-US_windows.msi"
